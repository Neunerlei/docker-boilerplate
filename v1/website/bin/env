#!/usr/bin/env bash
# This script was generated by bashly 1.1.2 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
env_usage() {
  if [[ -n $long_usage ]]; then
    printf "env - Environment Control application\n"
    echo

  else
    printf "env - Environment Control application\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  env COMMAND\n"
  printf "  env [COMMAND] --help | -h\n"
  printf "  env --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   similar to docker-compose up, but sets all the required environment variables for buildkit. (All docker command options are valid)\n" "up         "
  printf "  %s   simple alias to docker-compose stop\n" "stop       "
  printf "  %s   simple alias to docker-compose down\n" "down       "
  printf "  %s   simple alias to docker-compose stop and docker-compose up\n" "restart    "
  printf "  %s   builds the docker image for local testing\n" "build      "
  printf "  %s   simple alias to docker-compose logs (All docker command options are valid)\n" "logs       "
  printf "  %s   opens the current project in your browser.\n" "open       "
  printf "  %s   basically your docker-compose exec into the main app container\n" "ssh        "
  printf "  %s   initializes the project on your machine\n" "setup      "
  printf "  %s   Sub-commands used by the \"init\" command to prepare your system\n" "setup-step "
  printf "  %s   rebuilds the bashly application you are currently using, based on the sources\n" "rebuild-cli"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
env_up_usage() {
  if [[ -n $long_usage ]]; then
    printf "env up - similar to docker-compose up, but sets all the required environment variables for buildkit. (All docker command options are valid)\n"
    echo

  else
    printf "env up - similar to docker-compose up, but sets all the required environment variables for buildkit. (All docker command options are valid)\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  env up [OPTIONS] [...]\n"
  printf "  env up --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--attach, -f"
    printf "    By default, the containers are started daemonized, use this to attach to\n    their output\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_stop_usage() {
  if [[ -n $long_usage ]]; then
    printf "env stop - simple alias to docker-compose stop\n"
    echo

  else
    printf "env stop - simple alias to docker-compose stop\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  env stop [...]\n"
  printf "  env stop --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_down_usage() {
  if [[ -n $long_usage ]]; then
    printf "env down - simple alias to docker-compose down\n"
    echo

  else
    printf "env down - simple alias to docker-compose down\n"
    echo

  fi

  printf "Alias: clean\n"
  echo

  printf "%s\n" "Usage:"
  printf "  env down [...]\n"
  printf "  env down --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_restart_usage() {
  if [[ -n $long_usage ]]; then
    printf "env restart - simple alias to docker-compose stop and docker-compose up\n"
    echo

  else
    printf "env restart - simple alias to docker-compose stop and docker-compose up\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  env restart [...]\n"
  printf "  env restart --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_build_usage() {
  if [[ -n $long_usage ]]; then
    printf "env build - builds the docker image for local testing\n"
    echo

  else
    printf "env build - builds the docker image for local testing\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  env build [...]\n"
  printf "  env build --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_logs_usage() {
  if [[ -n $long_usage ]]; then
    printf "env logs - simple alias to docker-compose logs (All docker command options are valid)\n"
    echo

  else
    printf "env logs - simple alias to docker-compose logs (All docker command options are valid)\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  env logs [SERVICE] [...]\n"
  printf "  env logs --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SERVICE"
    printf "    Allows you to define which service you want to connect to\n"
    echo

  fi
}

# :command.usage
env_open_usage() {
  if [[ -n $long_usage ]]; then
    printf "env open - opens the current project in your browser.\n"
    echo

  else
    printf "env open - opens the current project in your browser.\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  env open\n"
  printf "  env open --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_ssh_usage() {
  if [[ -n $long_usage ]]; then
    printf "env ssh - basically your docker-compose exec into the main app container\n"
    echo

  else
    printf "env ssh - basically your docker-compose exec into the main app container\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  env ssh [SERVICE] [OPTIONS]\n"
  printf "  env ssh --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--cmd, -c COMMAND"
    printf "    By default, we will use \"bash\" as command, you can use \"sh\" or any other\n    command if you want to\n"
    printf "    Default: bash\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SERVICE"
    printf "    Allows you to define which service you want to connect to\n"
    echo

  fi
}

# :command.usage
env_setup_usage() {
  if [[ -n $long_usage ]]; then
    printf "env setup - initializes the project on your machine\n"
    echo

  else
    printf "env setup - initializes the project on your machine\n"
    echo

  fi

  printf "Alias: init\n"
  echo

  printf "%s\n" "Usage:"
  printf "  env setup\n"
  printf "  env setup --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_setup_step_usage() {
  if [[ -n $long_usage ]]; then
    printf "env setup-step - Sub-commands used by the \"init\" command to prepare your system\n"
    echo

  else
    printf "env setup-step - Sub-commands used by the \"init\" command to prepare your system\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  env setup-step COMMAND\n"
  printf "  env setup-step [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   prepares the .env.local file for the project\n" "prepare-env     "
  printf "  %s   copied from the .ddev directory to set up the permissions on the local files\n" "permissions     "
  printf "  %s   ensures that all files, required for the project setup are present\n" "create-files    "
  printf "  %s   installs the mkcert dependency to create ssl certificates for the local environment\n" "mkcert          "
  printf "  %s   tries to update the /etc/hosts file to match the ip and domain in your .env file\n" "hosts           "
  printf "  %s   runs the composer install in the command\n" "composer-install"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_setup_step_prepare_env_usage() {
  if [[ -n $long_usage ]]; then
    printf "env setup-step prepare-env - prepares the .env.local file for the project\n"
    echo

  else
    printf "env setup-step prepare-env - prepares the .env.local file for the project\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  env setup-step prepare-env\n"
  printf "  env setup-step prepare-env --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_setup_step_permissions_usage() {
  if [[ -n $long_usage ]]; then
    printf "env setup-step permissions - copied from the .ddev directory to set up the permissions on the local files\n"
    echo

  else
    printf "env setup-step permissions - copied from the .ddev directory to set up the permissions on the local files\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  env setup-step permissions\n"
  printf "  env setup-step permissions --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_setup_step_create_files_usage() {
  if [[ -n $long_usage ]]; then
    printf "env setup-step create-files - ensures that all files, required for the project setup are present\n"
    echo

  else
    printf "env setup-step create-files - ensures that all files, required for the project setup are present\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  env setup-step create-files\n"
  printf "  env setup-step create-files --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_setup_step_mkcert_usage() {
  if [[ -n $long_usage ]]; then
    printf "env setup-step mkcert - installs the mkcert dependency to create ssl certificates for the local environment\n"
    echo

  else
    printf "env setup-step mkcert - installs the mkcert dependency to create ssl certificates for the local environment\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  env setup-step mkcert\n"
  printf "  env setup-step mkcert --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_setup_step_hosts_usage() {
  if [[ -n $long_usage ]]; then
    printf "env setup-step hosts - tries to update the /etc/hosts file to match the ip and domain in your .env file\n"
    echo

  else
    printf "env setup-step hosts - tries to update the /etc/hosts file to match the ip and domain in your .env file\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  env setup-step hosts\n"
  printf "  env setup-step hosts --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_setup_step_composer_install_usage() {
  if [[ -n $long_usage ]]; then
    printf "env setup-step composer-install - runs the composer install in the command\n"
    echo

  else
    printf "env setup-step composer-install - runs the composer install in the command\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  env setup-step composer-install\n"
  printf "  env setup-step composer-install --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_rebuild_cli_usage() {
  if [[ -n $long_usage ]]; then
    printf "env rebuild-cli - rebuilds the bashly application you are currently using, based on the sources\n"
    echo

  else
    printf "env rebuild-cli - rebuilds the bashly application you are currently using, based on the sources\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  env rebuild-cli\n"
  printf "  env rebuild-cli --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do echo "- \${deps[$k]} = ${deps[$k]}"; done
  fi

}

# :command.user_lib
# _env/src/lib/dockerUtil.sh
determineDockerExecutable(){
  local DOCKER_EXECUTABLE=$(which docker)
  if [[ ${DOCKER_EXECUTABLE} ]]; then
    echo ${DOCKER_EXECUTABLE}
    return
  fi

  local PODMAN_EXECUTABLE=$(which podman)
  if [[ ${PODMAN_EXECUTABLE} ]]; then
    echo ${PODMAN_EXECUTABLE}
    return
  fi

  echo "Sorry, but I did not find docker or podman on your system" >&2
  exit 1
}

determineDockerComposeExecutable() {
  # Special switch for pod-man
  local PODMAN_PATH=$(which podman-compose)
	if [[ ${PODMAN_PATH} ]]; then
		echo ${PODMAN_PATH}
		return
	fi

	local COMPOSE_VERSION=$(docker compose version)

	if [[ ${COMPOSE_VERSION} == *v2* ]]; then
		echo "docker compose"
		return
	fi

	local COMPOSE_PATH=$(which docker-compose)

  local PODMAN_PATH=$(which podman)
  if [[ ${PODMAN_PATH} ]]; then
    echo ${PODMAN_PATH} compose
    return
	fi

  echo "Sorry, but I did not find docker-compose or 'docker compose' on your system" >&2
  exit 1
}

determineDockerRuntimeType(){
  local COMPOSE_EXECUTABLE=$(determineDockerComposeExecutable)
  if [[ ${COMPOSE_EXECUTABLE} == *podman* ]]; then
    echo "podman"
    return
  fi

  echo "docker"
}

provideDockerEnvironmentVariablesBasedOnRuntimeType(){
  echo "export BUILDKIT_PROGRESS=plain"
  echo "export COMPOSE_DOCKER_CLI_BUILD=1"
  echo "export DOCKER_BUILDKIT=1"

  if [[ ${DOCKER_RUNTIME_TYPE} == "podman" ]]; then
    echo "export DOCKER_RUNTIME=podman"
    echo "export DOCKER_USER=root"
  else
    echo "export DOCKER_RUNTIME=docker"
    echo "export DOCKER_USER=${DEFAULT_UID}:${DEFAULT_GID}"
    echo "export DOCKER_UID=${DEFAULT_UID}"
    echo "export DOCKER_GID=${DEFAULT_GID}"
  fi
}

isDockerContainerRunning(){
  local containerName=${1:-${DEFAULT_CONTAINER_NAME}}
  local containerId=$($DOCKER_EXECUTABLE ps -q -f name=${containerName})
  if [[ ${containerId} ]]; then
    return 0
  fi
  return 1
}

# _env/src/lib/envFileUtil.sh
getEnvFilePath() {
  ENV_FILE=${ENV_FILE:-"${PROJECT_ROOT_DIR}/.env"}
  echo ${ENV_FILE}
}

getEnvFileLocalTemplatePath() {
  ENV_FILE_TEMPLATE=${ENV_FILE_TEMPLATE:-"$(getEnvFileLocalPath).template"}
  echo ${ENV_FILE_TEMPLATE}
}

getEnvFileLocalPath() {
  ENV_FILE_LOCAL=${ENV_FILE_LOCAL:-"${ENV_FILE}.local"}
  echo ${ENV_FILE_LOCAL}
}

getEnvFileCompiledPath() {
  ENV_FILE_COMPILED=${ENV_FILE_COMPILED:-"${ENV_FILE}.dockerCompose"}
  echo ${ENV_FILE_COMPILED}
}

# Generates a combined output of the .env and .env.local env files and returns the name of the compiled file.
# This file will then be used by docker compose for local development
compileEnvFile() {
	ENV_FILE=$(getEnvFilePath)
	ENV_FILE_LOCAL=$(getEnvFileLocalPath)
	ENV_FILE_COMPILED=$(getEnvFileCompiledPath)

	rm -rf ${ENV_FILE_COMPILED}

	echo "# WARNING: COMPILED FILE! DON'T CHANGE STUFF HERE! THIS IS DONE AUTOMATICALLY" >> ${ENV_FILE_COMPILED}
	echo "# ================================================================================" >> ${ENV_FILE_COMPILED}
	echo "" >> ${ENV_FILE_COMPILED}

	if [ -f ${ENV_FILE} ]; then
		echo "# ................................................................................" >> ${ENV_FILE_COMPILED}
		echo "# CONTENTS OF: ${ENV_FILE}" >> ${ENV_FILE_COMPILED}
		echo "# ................................................................................" >> ${ENV_FILE_COMPILED}
		echo "" >> ${ENV_FILE_COMPILED}
		cat ${ENV_FILE} >> ${ENV_FILE_COMPILED}
	fi

	if [ -f ${ENV_FILE_LOCAL} ]; then
		echo "" >> ${ENV_FILE_COMPILED}
		echo "# ................................................................................" >> ${ENV_FILE_COMPILED}
		echo "# CONTENTS OF: ${ENV_FILE_LOCAL}" >> ${ENV_FILE_COMPILED}
		echo "# ................................................................................" >> ${ENV_FILE_COMPILED}
		echo "" >> ${ENV_FILE_COMPILED}
		cat ${ENV_FILE_LOCAL} >> ${ENV_FILE_COMPILED}
	fi

	echo ${ENV_FILE_COMPILED}
}

# Loads the script environment file or dies if it does not exist
loadEnvFile(){
  ENV_FILE=$(getEnvFilePath)

  if [ ! -f ${ENV_FILE} ]; then
    echo "Missing ${ENV_FILE} file! Please copy .env.tpl and add the secrets to it before continuing!";
    exit 1;
  fi

  source ${ENV_FILE}

  # We have to check if there is a *.local override version for the env file now...
  ENV_FILE_LOCAL=$(getEnvFileLocalPath)

  if [ -f ${ENV_FILE_LOCAL} ]; then
  	source ${ENV_FILE_LOCAL}
  fi
}

# _env/src/lib/networkUtil.sh
# Tries to find an open port
findOpenLocalPort(){
  read LOWERPORT UPPERPORT < /proc/sys/net/ipv4/ip_local_port_range
  while :
  do
    LOCAL_PORT="`shuf -i $LOWERPORT-$UPPERPORT -n 1`"
    ss -lpn | grep -q ":${LOCAL_PORT} " || break
  done
  echo $LOCAL_PORT
}

nextIp(){
    IP=$1
    IP_HEX=$(printf '%.2X%.2X%.2X%.2X\n' `echo $IP | sed -e 's/\./ /g'`)
    NEXT_IP_HEX=$(printf %.8X `echo $(( 0x$IP_HEX + 1 ))`)
    NEXT_IP=$(printf '%d.%d.%d.%d\n' `echo $NEXT_IP_HEX | sed -r 's/(..)/0x\1 /g'`)

    if [[ ${NEXT_IP} == *.0 ]]; then
        nextIp ${NEXT_IP}
        return
    fi

    echo "${NEXT_IP}"
}

# _env/src/lib/persistedConfig.sh
readPersistedConfig() {
  local KEY=$1
  local DEFAULT_VALUE=$2

  local STORAGE_FILE=$(getPersistedStorageFilePath)
  local VALUE=$(cat ${STORAGE_FILE} | ${DOCKER_EXECUTABLE} run --rm -i ${PERSISTED_STORAGE_JQ_IMAGE} --raw-output ".${KEY}")

  if [[ ${VALUE} == "null" ]]; then
    echo ${DEFAULT_VALUE}
  else
    echo ${VALUE}
  fi
}

writePersistedConfig() {
  local KEY=$1
  local VALUE=$2

  local STORAGE_FILE=$(getPersistedStorageFilePath)
  local TMP_FILE="${STORAGE_FILE}.tmp"

  $(cat ${STORAGE_FILE} | ${DOCKER_EXECUTABLE} run --rm -i ${PERSISTED_STORAGE_JQ_IMAGE} ".${KEY} = \"${VALUE}\"" > ${TMP_FILE})
  mv "${TMP_FILE}" ${STORAGE_FILE}
}

getPersistedStorageFilePath() {
  local STORAGE_DIRECTORY="${PERSISTED_STORAGE_PATH}"
  local STORAGE_FILE="${STORAGE_DIRECTORY}/${PERSISTED_STORAGE_FILE}"

  if [[ ! -f ${STORAGE_FILE} ]]; then
    mkdir -p ${STORAGE_DIRECTORY}
    echo "{}" > ${STORAGE_FILE}
  fi

  echo ${STORAGE_FILE}
}

# _env/src/lib/sshUtil.sh
#!/bin/bash

function sshagent_findsockets {
    find /tmp -uid $(id -u) -type s -name agent.\* 2>/dev/null
}

function sshagent_testsocket {
    if [ ! -x "$(which ssh-add)" ] ; then
        echo "ssh-add is not available; agent testing aborted"
        return 1
    fi

    if [ X"${1}" != X ] ; then
        export SSH_AUTH_SOCK=$1
    fi

    if [ X"${SSH_AUTH_SOCK}" = X ] ; then
        return 2
    fi

    if [ -S ${SSH_AUTH_SOCK} ] ; then
        ssh-add -l > /dev/null
        if [ $? = 2 ] ; then
            echo "Socket ${SSH_AUTH_SOCK} is dead!  Deleting!"
            rm -f ${SSH_AUTH_SOCK}
            return 4
        else
            echo "Found ssh-agent ${SSH_AUTH_SOCK}"
            return 0
        fi
    else
        echo "${SSH_AUTH_SOCK} is not a socket!"
        return 3
    fi
}

# Starts or reuses an existing ssh agent for the current process
startSshAgent(){
  IDENTITY_FILE=$(realpath ${1:-'~/.ssh/id_rsa'})

  # ssh agent sockets can be attached to a ssh daemon process or an
  # ssh-agent process.

  AGENTFOUND=0

  # Attempt to find and use the ssh-agent in the current environment
  if sshagent_testsocket ; then AGENTFOUND=1 ; fi

  # If there is no agent in the environment, search /tmp for
  # possible agents to reuse before starting a fresh ssh-agent
  # process.
  if [ ${AGENTFOUND} = 0 ] ; then
      for agentsocket in $(sshagent_findsockets) ; do
          if [ ${AGENTFOUND} != 0 ] ; then break ; fi
          if sshagent_testsocket ${agentsocket} ; then AGENTFOUND=1 ; fi
      done
  fi

  # If at this point we still haven't located an agent, it's time to
  # start a new one
  if [ ${AGENTFOUND} = 0 ] ; then
      eval `ssh-agent`
      ssh-add "${IDENTITY_FILE}"
  else
	# If the agent is already running, check if our keyfile exists in there, or add it
	if [[ ! $(ssh-add -l) == *${IDENTITY_FILE}* ]]; then
      ssh-add "${IDENTITY_FILE}"
	fi
  fi

  # Clean up
  unset AGENTFOUND
  unset agentsocket

  # Finally, show what keys are currently in the agent
  ssh-add -l
}

# Binds a foreign server's port to a local port through an SSH tunnel
# The generated tunnel will be closed 10 seconds after being opened if not picked up by another process
# - $HOST the SSH server to connect to
# - $TARGET_HOST the server we want to connect to through the tunnel (e.g. the database server)
# - $USER_NAME the SSH user name to connect with
# - $IDENTITY_FILE the private key file to use when connecting to the SSH server
# - $FOREIGN_PORT the port on $TARGET_HOST that should be mapped to $LOCAL_PORT
# - $LOCAL_PORT the port on the local machine that should be mapped to $FOREIGN_PORT
openSelfClosingSshTunnelOnLocalPort(){
  HOST=$1
  TARGET_HOST=$2
  USER_NAME=$3
  IDENTITY_FILE=$4
  FOREIGN_PORT=$5
  LOCAL_PORT=${6:-"8888"}

  startSshAgent ${IDENTITY_FILE}

  ssh -i "${IDENTITY_FILE}" \
      -f \
      -L ${LOCAL_PORT}:${TARGET_HOST}:${FOREIGN_PORT} \
      ${USER_NAME}@${HOST} \
      sleep 10
}

# _env/src/lib/util.sh
# Asserts that the provided command exist, or kills the script
assertCommandExists(){
  MESSAGE=${2:-"Error: the required executable ${1} does not exist"}
  if ! [ -x "$(command -v $1)" ]; then
    echo "${MESSAGE}" >&2
    exit 1
  fi
}

# Asks the user for confirmation and assumes yes should be the default answer
confirmDefaultYes(){
  QUESTION=${1:-"Are you sure?"}
  read -r -p "${QUESTION} [Y/n] " RESPONSE
  RESPONSE=${RESPONSE,,}

  if [[ "${RESPONSE}" =~ ^(yes|y)$ ]] || [[ ${RESPONSE} == "" ]]; then
    return
  fi

  false
}

# Asks the user for confirmation and assumes no should be the default answer
confirmDefaultNo(){
  QUESTION=${1:-"Are you sure?"}
  read -r -p "${QUESTION} [y/N] " RESPONSE
  RESPONSE=${RESPONSE,,}

  if [[ "${RESPONSE}" =~ ^(no|n)$ ]] || [[ ${RESPONSE} == "" ]]; then
  	false
    return
  fi
}

# Checks the last exit code and kills the script if it is bigger than 0
checkLastExitCodeOrDie(){
  CODE=${1:-$?}
  MESSAGE=${2:-"There was an issue with running a task"}

  if [ ${CODE} -ne 0 ]
  then
    echo "${MESSAGE}" >&2
    exit 1
  fi
}

determineHostType() {
  OS='unsupported';
  case "$OSTYPE" in
    #darwin*)  OS="OSX" ;;
    linux*)   OS="LINUX" ;;
    msys*)    OS="WINDOWS" ;;
    cygwin*)  OS="WINDOWS" ;;
  esac

  echo $OS
  return
}

determineOsPlatform() {
  if [[ $OS_TYPE == 'LINUX' ]]; then
    echo $(dpkg --print-architecture)
    return
  fi

  if [[ $OS_TYPE == 'WINDOWS' ]]; then
    echo %PROCESSOR_ARCHITECTURE%
    return
  fi
}

isWslMachine() {
  if [[ $(grep Microsoft /proc/version) ]]; then
    return
  fi
  if [[ $(grep microsoft /proc/version) ]]; then
    return
  fi

  false
}

# :command.command_functions
# :command.function
env_up_command() {
  # _env/src/up_command.sh
  ARGS=${other_args[*]}

  if ! [ ${args[--attach]} ]; then
  	ARGS+=" -d"
  fi

  $DOCKER_COMPOSE_EXECUTABLE --env-file $(compileEnvFile) up $ARGS

}

# :command.function
env_stop_command() {
  # _env/src/stop_command.sh
  ARGS=${other_args[*]}

  $DOCKER_COMPOSE_EXECUTABLE --env-file $(compileEnvFile) stop ${ARGS}

}

# :command.function
env_down_command() {
  # _env/src/down_command.sh
  ARGS=${other_args[*]}

  ${DOCKER_COMPOSE_EXECUTABLE} --env-file $(compileEnvFile) down ${ARGS}

}

# :command.function
env_restart_command() {
  # _env/src/restart_command.sh
  ARGS=${other_args[*]}

  ${DOCKER_COMPOSE_EXECUTABLE} --env-file $(compileEnvFile) restart ${ARGS}

}

# :command.function
env_build_command() {
  # _env/src/build_command.sh
  ARGS=${other_args[*]}

  ${DOCKER_EXECUTABLE} build --build-arg APP_ENV=prod . ${ARGS}

}

# :command.function
env_logs_command() {
  # _env/src/logs_command.sh
  ARGS=${other_args[*]}

  ${DOCKER_COMPOSE_EXECUTABLE} --env-file $(compileEnvFile) logs ${args[service]:-$SERVICE_NAME_APP} $ARGS

}

# :command.function
env_open_command() {
  # _env/src/open_command.sh
  open "${DOCKER_PROJECT_PROTOCOL}://${DOCKER_PROJECT_DOMAIN}"

}

# :command.function
env_ssh_command() {
  # _env/src/ssh_command.sh
  ${DOCKER_COMPOSE_EXECUTABLE} --env-file $(compileEnvFile) exec -ti ${args[service]:-$DEFAULT_SERVICE_NAME} ${args[--cmd]}

}

# :command.function
env_setup_command() {
  # _env/src/setup_command.sh
  if confirmDefaultYes "This script will help you getting all set up in your project. Should we get started?";
  then
    echo "Okay, here it goes...";
  else
    echo "Okay, let's do that another time!";
    exit
  fi

  run setup-step prepare-env
  run setup-step hosts
  run setup-step create-files
  run setup-step permissions
  run setup-step mkcert
  run up --build

  echo "Well, that should be it, you should now be able to open your project at $DOCKER_PROJECT_IP:443 or if you adjusted your hosts file: https://$DOCKER_PROJECT_DOMAIN"

}

# :command.function
env_setup_step_prepare_env_command() {
  # _env/src/setup_step_prepare_env_command.sh
  if [ -f $(getEnvFileLocalPath) ]; then
    return
  fi

  if confirmDefaultYes "There is currently no .env.local file. Do you want to create one based on .env.local.template";
  then
    echo "Okay, here it goes...";
  else
    echo "[SKIP]: Please note that you will probably need to create a .env.local file before you can run the project!";
    exit
  fi

  local OUTPUT_PATH=$(getEnvFileLocalPath)
  local TMP_PATH="${OUTPUT_PATH}.tmp"
  rm -rf ${TMP_PATH}
  cp $(getEnvFileLocalTemplatePath) ${TMP_PATH}

  IP=$(nextIp $(readPersistedConfig "DEV_IP" "${INITIAL_LOCAL_DEV_IP}"))

  echo "Please enter the project name (e.g. my-project):"
  read PROJECT_NAME

  # Ensure the project name string is url safe
  PROJECT_NAME=$(echo ${PROJECT_NAME} | sed -e 's/[^A-Za-z0-9_-]/-/g')
  DOMAIN="${PROJECT_NAME}.${DEFAULT_BASE_DOMAIN}"

  if confirmDefaultYes "I have generated the following domain for you: ${DOMAIN} (${IP}). Is this okay?";
  then
    echo "Okay, here it goes...";
  else
    echo "Please enter the domain you want to use (e.g. my-project.${DEFAULT_BASE_DOMAIN}):"
    read $DOMAIN
  fi

  sed -i "s/##COMPOSE_PROJECT_NAME##/${PROJECT_NAME}/g" ${TMP_PATH}
  sed -i "s/##DOCKER_PROJECT_DOMAIN##/${DOMAIN}/g" ${TMP_PATH}
  sed -i "s/##DOCKER_PROJECT_IP##/${IP}/g" ${TMP_PATH}

  writePersistedConfig "DEV_IP" ${IP}

  mv ${TMP_PATH} ${OUTPUT_PATH}

  # We must re-read the env file here, because otherwise we would not have the new values available
  loadEnvFile

}

# :command.function
env_setup_step_permissions_command() {
  # _env/src/setup_step_permissions_command.sh
  echo "[Setup]: Setting up permissions of files and folders"

  # This file can be modified to set the permissions of files and folders in your project when you set it up locally

  sudo find "$PROJECT_ROOT_DIR/bin" -type f -iname "*.sh" -exec chmod +x {} \;
}

# :command.function
env_setup_step_create_files_command() {
  # _env/src/setup_step_create_files_command.sh
  echo "[Setup]: Creating local files"
  # This file can be modified to create directories when you set up the project locally on your system

  # example:
  # mkdir -p -m 777 "$PROJECT_ROOT_DIR/var"

}

# :command.function
env_setup_step_mkcert_command() {
  # _env/src/setup_step_mkcert_command.sh
  echo "[Setup]: Using mkcert to create a local SSL certificate"

  # If "mkcert" is already installed
  if [[ -z "$(which mkcert)" ]]; then
    if [ -f /etc/redhat-release ]; then
      sudo yum update
      sudo yum install nss-tools
    fi

    if [ -f /etc/lsb-release ]; then
      sudo apt update
      sudo apt install libnss3-tools
    fi

    sudo rm -rf /usr/local/bin/mkcert
    LATEST_RELEASE=$(curl -Ls -o /dev/null -w %{url_effective} https://github.com/FiloSottile/mkcert/releases/latest | cut -d'/' -f8)
    VERSION_MKCERT=${VERSION_MKCERT:-$LATEST_RELEASE}
    echo "[mkcert] Required version $VERSION_MKCERT"
    curl -JLO "https://github.com/FiloSottile/mkcert/releases/download/${VERSION_MKCERT}/mkcert-${VERSION_MKCERT}-linux-${OS_PLATFORM}"
    checkLastExitCodeOrDie $?
    chmod +x mkcert-v*-linux-amd64
    sudo cp mkcert-v*-linux-amd64 /usr/local/bin/mkcert
    rm -rf mkcert-v*-linux-amd64
  fi

  echo "[mkcert] Installed version $VERSION_MKCERT"

  mkcert -install

  rm -rf ${DOCKER_SSL_DIR}
  mkdir -p ${DOCKER_SSL_DIR}

  mkcert -key-file ${DOCKER_SSL_DIR}/key.pem -cert-file ${DOCKER_SSL_DIR}/cert.pem $DOCKER_PROJECT_DOMAIN

}

# :command.function
env_setup_step_hosts_command() {
  # _env/src/setup_step_hosts_command.sh
  echo "[Setup]: Setting up your hosts file"

  if [ $OS_TYPE == 'LINUX' ]; then
    if isWslMachine; then
      echo 'Injecting hosts for wsl machine'

      if [ ! $(which gsudo) ]; then
        echo 'Sorry, but you are probably running a WSL ecosystem but don''t have "gsudo" installed. So I am not allowed to update your windows hosts file for you, skipping this step...'
        return
      fi

      cp -f $(realpath ./${BASH_SOURCE%/*})/_env/hosts.ps1 /mnt/c/tools/hosts.ps1
      gsudo -d "PowerShell -ExecutionPolicy Bypass -File C:\\tools\\hosts.ps1 remove ${DOCKER_PROJECT_DOMAIN} && PowerShell -ExecutionPolicy Bypass  -File C:\\tools\\hosts.ps1 add ${DOCKER_PROJECT_IP} ${DOCKER_PROJECT_DOMAIN}"

      return
    fi

    echo 'Injecting hosts for generic linux machine'
    HAS_MATCHES="$(grep -n "^[^#]*${DOCKER_PROJECT_DOMAIN}" /etc/hosts | cut -f1 -d:)"
      HOST_ENTRY="${DOCKER_PROJECT_IP} ${DOCKER_PROJECT_DOMAIN}"

    if [ ! -z "$HAS_MATCHES" ]
      then
        echo "Updating existing hosts entry."
        # iterate over the line numbers on which matches were found
        while read -r line_number; do
            # replace the text of each line with the desired host entry
            sudo sed -i "${line_number}s/.*/${HOST_ENTRY} /" /etc/hosts
        done <<< "$HAS_MATCHES"
      else
        echo "Adding new hosts entry."
        echo "$HOST_ENTRY" | sudo tee -a /etc/hosts > /dev/null
    fi
  fi;

}

# :command.function
env_setup_step_composer_install_command() {
  # _env/src/setup_step_composer_install_command.sh
  echo "[Setup]: Running composer install command"

  ${DOCKER_COMPOSE_EXECUTABLE} --env-file $(compileEnvFile) exec -ti ${DEFAULT_SERVICE_NAME} "composer" install

}

# :command.function
env_rebuild_cli_command() {
  # _env/src/rebuild_cli_command.sh
  if confirmDefaultYes "This will regenerate the bin/env script, based on the sources under bin/_env! Are you sure you want to continue?";
  then
    echo "Okay, lets do this...";
  else
    echo "Okay, aborting!";
    exit
  fi

  ${BASH_SOURCE%/*}/_env/bashly.sh generate
}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        env_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    up)
      action="up"
      shift
      env_up_parse_requirements "$@"
      shift $#
      ;;

    stop)
      action="stop"
      shift
      env_stop_parse_requirements "$@"
      shift $#
      ;;

    down | clean)
      action="down"
      shift
      env_down_parse_requirements "$@"
      shift $#
      ;;

    restart)
      action="restart"
      shift
      env_restart_parse_requirements "$@"
      shift $#
      ;;

    build)
      action="build"
      shift
      env_build_parse_requirements "$@"
      shift $#
      ;;

    logs)
      action="logs"
      shift
      env_logs_parse_requirements "$@"
      shift $#
      ;;

    open)
      action="open"
      shift
      env_open_parse_requirements "$@"
      shift $#
      ;;

    ssh)
      action="ssh"
      shift
      env_ssh_parse_requirements "$@"
      shift $#
      ;;

    setup | init)
      action="setup"
      shift
      env_setup_parse_requirements "$@"
      shift $#
      ;;

    setup-step)
      action="setup-step"
      shift
      env_setup_step_parse_requirements "$@"
      shift $#
      ;;

    rebuild-cli)
      action="rebuild-cli"
      shift
      env_rebuild_cli_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      env_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
env_up_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        env_up_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="up"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --attach | -f)

        # :flag.case_no_arg
        args['--attach']=1
        shift
        ;;

      --)
        shift
        other_args+=("$@")
        break
        ;;

      -?*)
        other_args+=("$1")
        shift
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_catch_all
        other_args+=("$1")
        shift

        ;;

    esac
  done

}

# :command.parse_requirements
env_stop_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        env_stop_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="stop"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --)
        shift
        other_args+=("$@")
        break
        ;;

      -?*)
        other_args+=("$1")
        shift
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_catch_all
        other_args+=("$1")
        shift

        ;;

    esac
  done

}

# :command.parse_requirements
env_down_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        env_down_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="down"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --)
        shift
        other_args+=("$@")
        break
        ;;

      -?*)
        other_args+=("$1")
        shift
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_catch_all
        other_args+=("$1")
        shift

        ;;

    esac
  done

}

# :command.parse_requirements
env_restart_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        env_restart_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="restart"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --)
        shift
        other_args+=("$@")
        break
        ;;

      -?*)
        other_args+=("$1")
        shift
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_catch_all
        other_args+=("$1")
        shift

        ;;

    esac
  done

}

# :command.parse_requirements
env_build_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        env_build_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="build"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --)
        shift
        other_args+=("$@")
        break
        ;;

      -?*)
        other_args+=("$1")
        shift
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_catch_all
        other_args+=("$1")
        shift

        ;;

    esac
  done

}

# :command.parse_requirements
env_logs_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        env_logs_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="logs"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --)
        shift
        other_args+=("$@")
        break
        ;;

      -?*)
        other_args+=("$1")
        shift
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_catch_all
        if [[ -z ${args['service']+x} ]]; then

          args['service']=$1
          shift
        else
          other_args+=("$1")
          shift
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
env_open_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        env_open_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="open"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
env_ssh_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        env_ssh_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="ssh"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --cmd | -c)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--cmd']="$2"
          shift
          shift
        else
          printf "%s\n" "--cmd requires an argument: --cmd, -c COMMAND" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['service']+x} ]]; then

          args['service']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['--cmd']:-} ]] || args['--cmd']="bash"

}

# :command.parse_requirements
env_setup_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        env_setup_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="setup"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
env_setup_step_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        env_setup_step_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    prepare-env)
      action="prepare-env"
      shift
      env_setup_step_prepare_env_parse_requirements "$@"
      shift $#
      ;;

    permissions)
      action="permissions"
      shift
      env_setup_step_permissions_parse_requirements "$@"
      shift $#
      ;;

    create-files)
      action="create-files"
      shift
      env_setup_step_create_files_parse_requirements "$@"
      shift $#
      ;;

    mkcert)
      action="mkcert"
      shift
      env_setup_step_mkcert_parse_requirements "$@"
      shift $#
      ;;

    hosts)
      action="hosts"
      shift
      env_setup_step_hosts_parse_requirements "$@"
      shift $#
      ;;

    composer-install)
      action="composer-install"
      shift
      env_setup_step_composer_install_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      env_setup_step_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
env_setup_step_prepare_env_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        env_setup_step_prepare_env_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="setup-step prepare-env"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
env_setup_step_permissions_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        env_setup_step_permissions_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="setup-step permissions"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
env_setup_step_create_files_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        env_setup_step_create_files_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="setup-step create-files"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
env_setup_step_mkcert_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        env_setup_step_mkcert_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="setup-step mkcert"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
env_setup_step_hosts_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        env_setup_step_hosts_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="setup-step hosts"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
env_setup_step_composer_install_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        env_setup_step_composer_install_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="setup-step composer-install"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
env_rebuild_cli_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        env_rebuild_cli_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="rebuild-cli"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.user_hooks
before_hook() {
  # _env/src/before.sh
  if [[ $action != setup* ]]; then
    if [[ -z "${COMPOSE_PROJECT_NAME}" ]]; then
      echo "Please set the COMPOSE_PROJECT_NAME environment variable to the name of your project!"
      exit 1
    fi
    if [[ -z "${DOCKER_PROJECT_IP}" ]]; then
      echo "Please set the DOCKER_PROJECT_IP environment variable to the ip of your project!"
      exit 1
    fi
  fi

}

# :command.initialize
initialize() {
  version="1.0.0"
  long_usage=''
  set -e

  # _env/src/initialize.sh
  PROJECT_ROOT_DIR=$(realpath ./${BASH_SOURCE%/*}/..)

  OS_TYPE=$(determineHostType)

  if [[ $OS_TYPE == 'unsupported' ]]; then
    echo 'Sorry, but we currently don''t support your operating system!'
    exit 1
  fi

  OS_PLATFORM=$(determineOsPlatform)

  loadEnvFile

  DOCKER_EXECUTABLE=$(determineDockerExecutable)
  DOCKER_COMPOSE_EXECUTABLE=$(determineDockerComposeExecutable)
  DOCKER_RUNTIME_TYPE=$(determineDockerRuntimeType)

  DEFAULT_SERVICE_NAME=${SERVICE_NAME:-app}
  DEFAULT_CONTAINER_NAME="${PROJECT_NAME:-project-without-name}-${DEFAULT_SERVICE_NAME}"
  DEFAULT_UID=${ENV_UID:-$(id -u)}
  DEFAULT_GID=${ENV_GID:-$(id -g)}
  DEFAULT_BASE_DOMAIN=${BASE_DOMAIN:-dev.local}

  INITIAL_LOCAL_DEV_IP=127.88.8.1

  PERSISTED_STORAGE_PATH=${PERSISTED_STORAGE_PATH:-${HOME}/.dev-local-boilerplate}
  PERSISTED_STORAGE_FILE=${PERSISTED_STORAGE_FILE:-config.json}
  PERSISTED_STORAGE_JQ_IMAGE=${PERSISTED_STORAGE_JQ_IMAGE:-ghcr.io/jqlang/jq:1.7}

  DOCKER_PROJECT_PROTOCOL=${DOCKER_PROJECT_PROTOCOL:-${APP_PROTOCOL:-https}}
  DOCKER_PROJECT_DOMAIN=${DOCKER_PROJECT_DOMAIN:-${APP_DOMAIN:-${COMPOSE_PROJECT_NAME}.${DEFAULT_BASE_DOMAIN}}}

  DOCKER_SSL_DIR=${PROJECT_ROOT_DIR}/docker/nginx/config/ssl

  $(provideDockerEnvironmentVariablesBasedOnRuntimeType)

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"
  before_hook

  case "$action" in
    "up") env_up_command ;;
    "stop") env_stop_command ;;
    "down") env_down_command ;;
    "restart") env_restart_command ;;
    "build") env_build_command ;;
    "logs") env_logs_command ;;
    "open") env_open_command ;;
    "ssh") env_ssh_command ;;
    "setup") env_setup_command ;;
    "setup-step") env_setup_step_command ;;
    "setup-step prepare-env") env_setup_step_prepare_env_command ;;
    "setup-step permissions") env_setup_step_permissions_command ;;
    "setup-step create-files") env_setup_step_create_files_command ;;
    "setup-step mkcert") env_setup_step_mkcert_command ;;
    "setup-step hosts") env_setup_step_hosts_command ;;
    "setup-step composer-install") env_setup_step_composer_install_command ;;
    "rebuild-cli") env_rebuild_cli_command ;;
  esac
}

initialize
run "$@"
